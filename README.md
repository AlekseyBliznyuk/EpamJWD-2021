# EpamJWD-2021
**Что такое JVM?**
 
 JVM (Java Virtual Machine) - виртуальная машина Java - основная часть исполняющей системы Java, так называемой Java Runtime Environment (JRE). 
Источник: https://www.examclouds.com/ru/java/java-core-russian/jdk-jre-jvm

**Что такое JDK?**
 
 JDK (Java Development Kit) - комплект разработчика приложений на языке Java, включающий в себя компилятор, стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему JRE. Источник: https://www.examclouds.com/ru/java/java-core-russian/jdk-jre-jvm

**Что такое JRE?**
 
 JRE (Java Runtime Environment) - минимальная реализация виртуальной машины, необходимая для исполнения Java приложений, без компилятора и других средств разработки.
Источник: https://www.examclouds.com/ru/java/java-core-russian/jdk-jre-jvm

**Даны корректные исходные файлы: Hello.java и hello.cpp. Каждый из них преобразуется в исполняемый код, который запускается на выполнение. Назовем данный процесс жизненным циклом приложения. В чем отличие жизненных циклов этих приложений?**
 
 Приложения java запускаются в виртуальной среде JVM, а C++ в операционной системе.
Сlass-файлы Java в отличие от приложений С++ не содержат инструкций для конкретного процессора и могут запускаться на разных платформах.
Программы java не могут напрямую работать с памятью в отличие от С++
Все стандартные библиотеки уже включены в JRE их не нужно добавлять в исходные файлы на Java.
Источник:http://www.javable.com/tutorials/fesunov/lesson1/

 ****Перечислите группы примитивных типов данных и состав каждой группы****
 
 В Java есть 8 примитивных типов, которые делят на 4 группы:

1.Числовые.Делятся на:

а) Числовые - byte, short, int, long,

b) Числа с плавающей точкой (иначе вещественные) - float, double

2.Логический - boolean

3.Символьный - char

 Источник: https://www.examclouds.com/ru/java/java-core-russian/literals-russian
 
**Какой размер данного булевского типа?**
 
 В массивах используется тип byte, поэтому в памяти будет занято 8 бит. Источник: https://ru.wikibooks.org/wiki/Java/
 
**Какой размер данного символьного типа?**
 
 2 байта. Источник: https://metanit.com/java/tutorial/2.12.php
 
**Какими литералами можно инициализировать символьную переменную?**
 
char

Источник: https://www.examclouds.com/ru/java/java-core-russian/literals-russian
 
**Какие есть виды переменных?**
 
Есть восемь видов переменных:

1.Переменная класса является поле объявляется с помощью ключевого слова в staticпределах класса декларации ( §8.3.1.1 ), или с или без ключевого слова staticв объявлении интерфейса ( §9.3 ).

2.Переменная экземпляра является полем , объявленным в объявлении класса без использования ключевого слова static ( §8.3.1.1 ).

3.Компоненты массива - это безымянные переменные, которые создаются и инициализируются значениями по умолчанию ( §4.12.5 ) всякий раз, когда создается новый объект, являющийся массивом ( §10 ( Массивы ) , §15.10.2 ). Компоненты массива фактически перестают существовать, когда на массив больше не ссылаются.

4.Параметры метода ( §8.4.1 ) именуют значения аргументов, передаваемых методу.

5.Параметры конструктора ( §8.8.1 ) именуют значения аргументов, передаваемых конструктору.

6.Лямбда-параметры ( §15.27.1 ) именуют значения аргументов, передаваемых в тело лямбда-выражения ( §15.27.2 ).

7.Параметр исключения создается каждый раз , когда исключение ловится catchпунктом в tryзаявлении ( §14.20 ).

8.Локальные переменные объявляются операторами объявления локальных переменных ( §14.4 ).

Источник:https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.3

**В какой области памяти хранятся локальные переменные?**
 
 Все локальные переменные примитивных типов полностью хранятся в стеке потоков и не видны другим потокам. Источник: https://topjava.ru/blog/stack-and-heap-in-java/
 
**В какой области памяти хранятся аргументы метода?**

Аргументы метода хранятся в стеке. Источник: https://topjava.ru/blog/stack-and-heap-in-java
 
**В какой области памяти хранятся объекты?**
 
 Все объекты хранятся в куче. Источник: https://topjava.ru/blog/stack-and-heap-in-java
 
**В какой области памяти хранятся ссылки на объекты?**

Cсылки на объекты хранятся в стеке (Java Virtual Machine stack), но если ссылка на объект является полем объекта, то данная ссылка вместе с объектом хранится в куче (heap) вместе с этим объектом.
Источник: https://topjava.ru/blog/stack-and-heap-in-java
 
**В какой области памяти хранятся массивы?**

Массивы хранятся в куче. Ссылки на них - в стеке. Источник: http://www.quizful.net/interview/java/java-local-variables
 
**Дайте определение массива.**
 
 В языке программирования Java массивы являются объектами (§4.3.1), который динамически создан и может
быть назначен переменным типа Object (§4.3.2). Все методы класса Object могут быть вызваны в массиве. Объект массива
содержит ряд переменных. Количество переменных может быть равно нулю, и в этом случае массив называется пустым. 
Переменные, содержащиеся в массиве, не имеют имен, вместо этого на них ссылаются выражения доступа к массиву, 
которые используют неотрицательные целочисленные значения индекса. Эти переменные называются компонентами массива.
Если в массиве n компонентов, мы говорим, что n - длина массива а для ссылок на компоненты массива используются 
целочисленные индексы от 0 до n - 1, включительно. Все компоненты массива имеют один и тот же тип, называемый 
типом компонента массив. Если типом компонента массива является T, то тип самого массива пишется T []. Тип 
компонента массива может сам быть типом массива. Компоненты такого массива могут содержать ссылки на подмассивы.
Если, начиная с любого массива типа, рассматривается его компонентный тип, а затем (если это также тип массива) 
компонентный тип этого типа и т. д., в конечном итоге нужно достичь компонента тип, не являющийся типом массива, 
это называется типом элемента исходного массива, и компоненты на этом уровне структуры данных называются элементами
исходный массив. В некоторых ситуациях элемент массива может быть массивом: если тип элемента - Object, Cloneable
или java.io.Serializable, затем некоторые или все элементов могут быть массивами, потому что любой объект массива
может быть назначен любому переменная этих типов. 
Источник. стр. 399 https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf
 
**Назовите 3 этапа создания массива. Какие действия выполняет JVM на каждом этапе?**

Процесс создания массива можно разделить на три этапа:

Объявление (declaration)

Создание (instantation)

Инициализация  (initialization)

Объявление (declaration) массива

На этом этапе определяется только переменная типа ссылка (reference) на массив, содержащая тип массива. Для этого записывается имя типа элементов массива, квадратными скобками указывается, что объявляется ссылка на массив, а не простая переменная, и перечисляются имена переменных ссылочного типа.

Создание (instantation) массива

На этом этапе указывается количество элементов массива, называемое его размером, выделяется место для массива в оперативной памяти, переменной-ссылке присваивается оператором = адрес массива. Все эти действия производятся оператором new за которым следует тип элементов массива.

Инициализация (initialization) массива

На этом этапе элементы массива получают начальные значения. Инициализировать элементы массива значениями можно несколькими способами:

1)Присвоить каждому элементу массива конкретное значение (это можно сделать например в цикле, но до этого массив уже должен быть объявлен и создан)

2)Инициализировать массив при помощи перечисления значений его элементов в фигурных скобках (это можно сделать как на этапе объявления, так и на этапе создания, но синтаксис при этом разный)

Источник: http://pr0java.blogspot.com/2015/05/1.html

**Приведите различные способы инициализации массива.** 

 Способы инициализации массива:
1. на этапе объявления:
  А. int[] ar = {1,2}.
  Б. int[] ar = new int[]{1,2}.
2. на этапе создания:
  А. int[] ar;
  ar = new int[]{1,2}.
  Б. Присваивание значений элементам массива с использованием индексов (для этого можно использовать циклы):
String[] seasons  = new String[4];
seasons[0] = "Winter";
seasons[1] = "Spring";
seasons[2] = "Summer";
seasons[3] = "Autumn".

Источник: https://javarush.ru/groups/posts/massivy-java

**Дан массив**
**int[] values = {...};**
**//в фигурных скобках корректный список инициализации.**
**Есть ли различие в проходе по массиву циклами:**
**1. for(int i=0; i < values.length; i++) {...}**
**2. for(int value : values) {...}**
**Если да, то в чем различие заключается?**
**Как называется каждый цикл?**
 
1. for(int i=0; i < values.length; i++) {...} - цикл с параметрами, цикл по счетчику, цикл по записи

2. for(int value : values) {...} - цикл foreach, цикл по чтению
Разница:

1. В for цикле при изменении индекса i в теле цикла или использовании прерывания можно изменить порядок прохода по массиву. В for each цикле проход по массиву происходит с помощью итератора полностью через все элементы по порядку.

2. В for цикле при проходе по массиву мы напрямую обращаемся к элементу массива и таким образом можем его изменить, а в for each – нет, т.к. в данном цикле мы работаем с итерационной переменной, а не с элементом массива.

3. Использование for each цикла не наносит никакого ущерба производительности. На самом деле такой цикл может предложить небольшое преимущество в производительности над циклом for в некоторых обстоятельствах, так как он подсчитывает границу индекса массива только один раз.

4. В for each цикле исключается возможность выхода за пределы массива.

Порядок массива: менять можно только в for.

Преимущество производительности: у foreach(один раз вычисляет границу индекса массива)

Прямое обращение: только у foreach.

Источник: https://javarush.ru/groups/posts/for-each-java/
 
**Можно ли создать массив нулевой длины? Если да, то для каких целей он необходим?**
 
 Можно создавать и использовать массивы нулевой длины,но инициализировать такой массив нельзя, так как у него просто нет элементов которые можно инициализировать.
 Пустой массив принято использовать в тех местах программы, где заранее неизвестно, будут элементы или нет. Если элементы будут, то возвращается непустой массив, если элементов нет - пустой массив. Примером может служить массив строк который передается в метод main() и содержит аргументы командной строки, а если их нет, то возвращается пустой массив.
Пустой массив лучше, чем null, потому что не требует отдельного if'а для обработки. То же верно для списков и других коллекций. Именно поэтому существуют методы Collections.emptyList, emptySet, emptyMap. Источник: http://pr0java.blogspot.com/2015/05/1.html
 
**Что собой представляет двумерный массив? Многомерный массив?**
 
Двумерный массив в Java — это массив массивов, то есть в каждой его ячейке находится ссылка на некий
массив. Но гораздо проще его представить в виде таблицы, у которой задано количество строк (первое измерение)
и количество столбцов (второе измерение). Многомерный массив в Java – это массив, содержащий массивы различных 
размеров в качестве своих элементов. Его также называют “массив массивов”, или “неровный массив”. 
Источник: https://javarush.ru/groups/posts/mnogomernye-massivy
 
**Перечислите ссылочные типы.**

Любой класс в Java — это ссылочный тип. String - стандартный пример ссылочного типа + Интерфейсы + Перечисления. Источник: https://javarush.ru/groups/posts/2642-ssihlochnihe-tipih-dannihkh-v-java 
 
**Какая структура у java-файла (внутренности класса не указывать)?**

Общая форма файла, содержащего исходный код Java, может быть следующая:

- одиночный оператор package (необязателен);

- любое количество операторов import (необязательны);

- одиночный открытый (public) класс (необязателен);

- любое количество классов пакетного уровня доступа (необязательны);

- описания интерфейсов (необязательны);

- комментарии (необязательны).

Классы в файле могут отсутствовать. При этом в результате компиляции не будет создан ни один файл с расширением .class.
Источник: И.Н. Блинов,Java. Методы программирования(c.20)

**Какие из элементов структуры являются обязательными?**
 
 Не считая импортов и указания имен пакетов, весь рабочий код находится внутри классов. При этом, за редким исключением, каждый класс должен описываться в отдельном файле, имя файла должно совпадать с именем класса. Например, если создается класс HelloWorldApp, то он сохраняется в файле HelloWorldApp.java.

Один из классов обязательно должен содержать метод-функцию main(), которая является точкой входа в java-программу. В случае однофайловой программы, метод main() должен быть в этом единственном файле. Как называется класс, содержащий main(), не важно. Источник: https://younglinux.info/java/structure
 
**Для чего предназначены пакеты?**
 
 Пакеты позволяют организовать классы логически в наборы. По умолчанию java уже имеет ряд встроенных
пакетов, например, java.lang, java.util, java.io и т.д. Кроме того, пакеты могут иметь вложенные пакеты. 
Организация классов в виде пакетов позволяет избежать конфликта имен между классами. Ведь нередки ситуации, 
когда разработчики называют свои классы одинаковыми именами. Принадлежность к пакету позволяет гарантировать
однозначность имен.
Источник: Https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf
 
**Как выглядит полное имя класса?**
 
 Полным именем класса считается имя, состоящее из всех пакетов, перечисленных через точку и имени класса. Источник: https://javarush.ru/quests/lectures/questsyntax.level02.lecture09
 
**Для чего предназначен оператор import?**

Оператор import служит только для удобства программирования и не является обязательным с формальной точки зрения для создания завершенной программы нa java.Но если в прикладном коде приходится ссылаться на несколько десятков классов, то оператор import значительно сокращает объем вводимого исходного кода. Источник: https://pro-java.ru/java-dlya-nachinayushhix/import-paketov-v-java
 
**Для чего предназначен статический импорт?**

Благодаря статическому импорту появляется возможность ссылаться на статические члены непосредственно по именам, не уточняя их именем класса. Источник: https://pro-java.ru/java-dlya-nachinayushhix/import-paketov-v-java

**Сколько внешних публичных классов можно объявить в одном java-файле?**

На каждую единицу компиляции (файл *.java) должно быть не более одного внешнего публичного класса и любое количество классов пакетного уровня доступа. Это ограничение облегчает компилятору Java поиск именованного класса в пакете. Источник: http://proglang.su/java/classes-and-objects

**Может ли синтаксически правильный java-файл иметь имя 1.java? Если да, то какие ограничения?**

Да, может. Но только в том случае, если в файле нет внешнего public класса. После компиляции файла 1.java компилятор создаст файл или файлы с расширением .class по именам package-private классов. Если же внешний public класс есть, то имя файла должно совпадать с именем public класса, а имя класса не может начинаться с цифры.
Источник: https://javarush.ru/groups/posts/1392-oshibki-nachinajujshikh-java-programmistov-chastjh-1

**Допустим, в одном java-файле объявлены два синтаксически правильных внешних класса. Какие могут быть результаты компиляции данного файла?**
 
Возможны 2 варианта результата компиляции:

1. Ошибка компиляции:

1.1. В случае, если оба класса объявлены с модификатором доступа public;

1.2. либо имя public класса не совпадает (с учетом регистра) с именем файла, в котором он объявлен.

2. Успешная компиляция:

2.1. Если имя public класса совпадает (с учетом регистра) с именем файла, в котором он объявлен, а второй класс имеет пакетный уровень доступа (package private);

2.2. либо в файле объявлены 2 класса с пакетным уровнем доступа.

В результате успешной компиляции будут созданы 2 class-файла, имена которых будут совпадать с именами классов, объявленных в исходном файле. Источник: https://coderoad.ru/2336692/
 
**Как записывается заголовок метода main() раннер-класса (т.е. класса, который может стартовать из-под JVM)?
Это единственный способ?**
 
 public static void main(String[] args)
 
  public static void main(String args[])
  
   public static void main(String...args)
 
 Источник: http://grep.cs.msu.ru/kufas.ru/programming_java128.htm
 
**Может ли один java-файл содержать два и более раннер-класса?**
 
 Может. Но только один такой раннер-класс может быть public, а остальные
package-private раннер-класы. Либо все такие раннер-классы должны быть с уровнем
доступа раннер-класс. Имена классов внутри пакета должны быть разными (иначе
ошибка компиляции).
Источник: https://qastack.ru/programming/968347
 
**Можно ли определить метод main() с другими модификаторами?**
 Можем написать основной метод со всеми вышеперечисленными ключевыми словами (которые на практике практически не применяются): final static synchronized strictfp void main(final String[] args) { }
 Источник: https://www.baeldung.com/java-main-method
 
**Может ли в классе быть два и более метода main()?**
**Если да, то приведите пример.** 

Да. Пример:

public class MultipleMain{

  public static void main(String args[])
  
  {
  
      main(1);     
      
      main('c');      
      
      main("MyString");
      
  }

  public static void main(int i)
  
  {
     
     System.out.println("Inside Overloaded main()");
     
  }

  public static void main(char i)
  
  {
     
     System.out.println("Inside Overloaded main()");
     
     
  }
  
  
  public static void main(String str)
  
  {
     
     
     System.out.println("Inside Overloaded main()");
  
  
  }


**Может ли в классе быть два метода main(), один из которых раннер, а второй метод main() отличается от первого только отсутствием модификатора static?
Если да, то приведите пример вызова второго метода. **

Нет, так как программа не скомпилируется,ибо main() - статический метод. Источник: http://zonakoda.ru/vsyo-o-metode-main.html

**В корне проекта имеется файл HelloWorld.java, пути к необходимым ресурсам открыты.
Создайте bat-файл для запуска приложения на выполнение.**
 
 @echo off
 
 javac HelloWorld.java
 
 java Main
 
 pause
 
 
**В корне проекта имеется**
**1. папка src для исходных java-файлов, а в ней – файл HelloArgs.java, который выводит приветствие для каждого аргумента командной строки;**
**2. папка bin для class-файлов.**
**Пути к компилятору и JVM открыты, переменная CLASSPATH не установлена.**
**Создайте bat-файл для запуска приложения с двумя аргументами командной строки clever и 25007 на выполнение.**
 
 @echo off
 
javac -sourcepath src -d bin src/HelloArgs.java

java -classpath bin HelloArgs clever 25007
 
**Имеется корректный файл helloWorld.jar.
Создайте bat-файл для запуска приложения на выполнение.**
 
 java -jar HelloWorld.jar
 
**Какие есть виды комментариев?**

//Строчный комментарий

/*

*Блочный комментарий

*/
Источник: https://javarush.ru/groups/posts/607-kommentarii-v-java--ne-vsje-tak-prosto
