# EpamJWD-2021
**Что такое JVM?**
 
 JVM (Java Virtual Machine) - виртуальная машина Java - основная часть исполняющей системы Java, так называемой Java Runtime Environment (JRE). 
Источник: https://www.examclouds.com/ru/java/java-core-russian/jdk-jre-jvm

**Что такое JDK?**
 
 JDK (Java Development Kit) - комплект разработчика приложений на языке Java, включающий в себя компилятор, стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему JRE. Источник: https://www.examclouds.com/ru/java/java-core-russian/jdk-jre-jvm

**Что такое JRE?**
 
 JRE (Java Runtime Environment) - минимальная реализация виртуальной машины, необходимая для исполнения Java приложений, без компилятора и других средств разработки.
Источник: https://www.examclouds.com/ru/java/java-core-russian/jdk-jre-jvm

**Даны корректные исходные файлы: Hello.java и hello.cpp. Каждый из них преобразуется в исполняемый код, который запускается на выполнение. Назовем данный процесс жизненным циклом приложения. В чем отличие жизненных циклов этих приложений?**
 
 Исходная Java-программа должна быть в файле с расширением java . Программа транслируется в байт-код компилятором javac.exe . Оттранслированная в байт-код программа имеет расширение class . Для запуска программы нужно вызвать интерпретатор java.exe , указав в параметрах вызова, какую программу ему следует выполнять. Кроме того, ему нужно указать, какие библиотеки нужно использовать при выполнении программы. Библиотеки размещены в файлах с расширением jar (в предыдущих версиях SDK использовались файлы *.zip и некоторые библиотеки все еще в таких файлах). Источник:http://www.javable.com/tutorials/fesunov/lesson1/

С++:Сначала программа передается препроцессору, который выполняет директивы, содержащиеся в ее тексте (например, включение в текст так называемых заголовочных файлов — текстовых файлов, в которых содержатся описания используемых в программе элементов).
Получившийся полный текст программы поступает на вход компилятора, который выделяет лексемы, а затем на основе грамматики языка распознает выражения и операторы, построенные из этих лексем. При этом компилятор выявляет синтаксические ошибки и в случае их отсутствия строит объектный модуль.
Компоновщик, или редактор связей, формирует исполняемый модуль программы, подключая к объектному модулю другие объектные модули, в том числе содержащие функции библиотек, обращение к которым содержится в любой программе (например, для осуществления вывода на экран). Если программа состоит из нескольких исходных файлов, они компилируются по отдельности и объединяются на этапе компоновки. Исполняемый модуль имеет расширение .ехе и запускается на выполнение обычным образом.
Источник:https://itandlife.ru/programming/cpp/etapy-kompilyacii-i-komponovki-programm-na-yazyke-c/
 
 ****Перечислите группы примитивных типов данных и состав каждой группы****
 
 В Java есть 8 примитивных типов, которые делят на 4 группы:

Целые числа - byte, short, int, long

Числа с плавающей точкой (иначе вещественные) - float, double

Логический - boolean

Символьный - char

Целочисленные типы


Целочисленные типы различаются между собой только диапазонами возможных значений, например, 
для хранения номера элемента в таблице Менделеева пока хватит переменной типа byte.

Тип        Размер (бит)    Диапазон\
byte    8 бит            от -128 до 127\
short    16 бит            от -32768 до 32767\
char    16 бит            беззнаковое целое число, представляющее собой символ UTF-16 (буквы и цифры)\
int        32 бит            от -2147483648 до 2147483647\
long    64 бит            от -9223372036854775808L до 9223372036854775807L\


Типы с плавающей точкой\
Тип        Размер (бит)    Диапазон\
float    32                от 1.4e-45f до 3.4e+38f\
double    64                от 4.9e-324 до 1.7e+308


Логический тип\
Тип            Размер (бит)                                            Значение\
boolean        8 (в массивах), 32 (не в массивах используется int)        true (истина) или false (ложь)\

 Ссылочные типы - это все остальные типы: классы, перечисления и интерфейсы, например, объявленные в стандартной библиотеке Java, а также массивы.
 
**Какой размер данного булевского типа?**
 
 В стандартной реализации Sun JVM и Oracle HotSpot JVM тип boolean занимает 4 байта (32 бита), как и тип int. Однако, в определенных версиях JVM имеются реализации, где в массиве boolean каждое значение занимает по 1-му биту. Источник: https://ru.wikibooks.org/wiki/Java/
 
**Какой размер данного символьного типа?**
 
 2 байта. Источник: https://metanit.com/java/tutorial/2.12.php
 
**Какими литералами можно инициализировать символьную переменную?**
 
char

Источник: https://www.examclouds.com/ru/java/java-core-russian/literals-russian
 
**Какие есть виды переменных?**
 
 В Java есть 3 вида переменных:
 
 локальные переменные;
 
 переменные экземпляра;
 
 класс / статические переменные.
Источник: https://hr-vector.com/java/tipy-peremennyh

**В какой области памяти хранятся локальные переменные?**
 
 Все локальные переменные примитивных типов полностью хранятся в стеке потоков и не видны другим потокам. Источник: https://topjava.ru/blog/stack-and-heap-in-java/
 
**В какой области памяти хранятся аргументы метода?**

Аргументы метода хранятся в стеке. Источник: https://topjava.ru/blog/stack-and-heap-in-java
 
**В какой области памяти хранятся объекты?**
 
 Все объекты хранятся в куче. Источник: https://topjava.ru/blog/stack-and-heap-in-java
 
**В какой области памяти хранятся ссылки на объекты?**

Ссылки на объекты хранятся в стеке. Источник: https://topjava.ru/blog/stack-and-heap-in-java
 
**В какой области памяти хранятся массивы?**

Массивы хранятся в куче. Ссылки на них - в стеке. Источник: http://www.quizful.net/interview/java/java-local-variables
 
**Дайте определение массива.**
 
 В языке программирования Java массивы являются объектами (§4.3.1), который динамически создан и может
быть назначен переменным типа Object (§4.3.2). Все методы класса Object могут быть вызваны в массиве. Объект массива
содержит ряд переменных. Количество переменных может быть равно нулю, и в этом случае массив называется пустым. 
Переменные, содержащиеся в массиве, не имеют имен, вместо этого на них ссылаются выражения доступа к массиву, 
которые используют неотрицательные целочисленные значения индекса. Эти переменные называются компонентами массива.
Если в массиве n компонентов, мы говорим, что n - длина массива а для ссылок на компоненты массива используются 
целочисленные индексы от 0 до n - 1, включительно. Все компоненты массива имеют один и тот же тип, называемый 
типом компонента массив. Если типом компонента массива является T, то тип самого массива пишется T []. Тип 
компонента массива может сам быть типом массива. Компоненты такого массива могут содержать ссылки на подмассивы.
Если, начиная с любого массива типа, рассматривается его компонентный тип, а затем (если это также тип массива) 
компонентный тип этого типа и т. д., в конечном итоге нужно достичь компонента тип, не являющийся типом массива, 
это называется типом элемента исходного массива, и компоненты на этом уровне структуры данных называются элементами
исходный массив. В некоторых ситуациях элемент массива может быть массивом: если тип элемента - Object, Cloneable
или java.io.Serializable, затем некоторые или все элементов могут быть массивами, потому что любой объект массива
может быть назначен любому переменная этих типов. 
Источник. стр. 399 https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf
 
**Назовите 3 этапа создания массива. Какие действия выполняет JVM на каждом этапе?**

Процесс создания массива можно разделить на три этапа:

Объявление (declaration)

Создание (instantation)

Инициализация  (initialization)

Объявление (declaration) массива

На этом этапе определяется только переменная типа ссылка (reference) на массив, содержащая тип массива. Для этого записывается имя типа элементов массива, квадратными скобками указывается, что объявляется ссылка на массив, а не простая переменная, и перечисляются имена переменных ссылочного типа.

Создание (instantation) массива

На этом этапе указывается количество элементов массива, называемое его размером, выделяется место для массива в оперативной памяти, переменной-ссылке присваивается оператором = адрес массива. Все эти действия производятся оператором new за которым следует тип элементов массива.

Инициализация (initialization) массива

На этом этапе элементы массива получают начальные значения. Инициализировать элементы массива значениями можно несколькими способами:

1)Присвоить каждому элементу массива конкретное значение (это можно сделать например в цикле, но до этого массив уже должен быть объявлен и создан)

2)Инициализировать массив при помощи перечисления значений его элементов в фигурных скобках (это можно сделать как на этапе объявления, так и на этапе создания, но синтаксис при этом разный)

Источник: http://pr0java.blogspot.com/2015/05/1.html

**Приведите различные способы инициализации массива.** 

Инициализация массива — это заполнение его конкретными данными (не по умолчанию).
1-ый способ: Создание массива:
String[] seasons  = new String[4]; /* объявили и создали массив. Java выделила память под массив из 4 строк, и сейчас в каждой ячейке записано значение null (поскольку строка — ссылочный тип)*/

Инициализацию также можно провести по-другому, совместив с инициализацией и объявлением: 

String[] seasons  = new String[] {"Winter", "Spring", "Summer", "Autumn"};
 
Более того, оператор new можно опустить: 

String[] seasons  = {"Winter", "Spring", "Summer", "Autumn"};

Источник: https://javarush.ru/groups/posts/massivy-java

**Дан массив**
**int[] values = {...};**
**//в фигурных скобках корректный список инициализации.**
**Есть ли различие в проходе по массиву циклами:**
**1. for(int i=0; i < values.length; i++) {...}**
**2. for(int value : values) {...}**
**Если да, то в чем различие заключается?**
**Как называется каждый цикл?**
 
 Когда нужно обработать все элементы массива или коллекции. “For each” с английского так и переводится — “для каждого”.
 
 For-each не подходит, если вы хотите внести изменения в массив. Например, не получится организовать сортировку массива, не меняя его элементы местами, не получится изменить элементы массива values, посредством изменения value. В заключении foreach отлично проходит для чтения или обработки массива, а классический for для непосредственной работы с массивом. Первый - классический цикл for, второй - for-each. Источник: https://javarush.ru/groups/posts/for-each-java/
 
**Можно ли создать массив нулевой длины? Если да, то для каких целей он необходим?**
 
 Можно создавать и использовать массивы нулевой длины,но инициализировать такой массив нельзя, так как у него просто нет элементов которые можно инициализировать.
 Пустой массив принято использовать в тех местах программы, где заранее неизвестно, будут элементы или нет. Если элементы будут, то возвращается непустой массив, если элементов нет - пустой массив. Примером может служить массив строк который передается в метод main() и содержит аргументы командной строки, а если их нет, то возвращается пустой массив.
Пустой массив лучше, чем null, потому что не требует отдельного if'а для обработки. То же верно для списков и других коллекций. Именно поэтому существуют методы Collections.emptyList, emptySet, emptyMap. Источник: http://pr0java.blogspot.com/2015/05/1.html
 
**Что собой представляет двумерный массив? Многомерный массив?**
 
Двумерный массив в Java — это массив массивов, то есть в каждой его ячейке находится ссылка на некий
массив. Но гораздо проще его представить в виде таблицы, у которой задано количество строк (первое измерение)
и количество столбцов (второе измерение). Многомерный массив в Java – это массив, содержащий массивы различных 
размеров в качестве своих элементов. Его также называют “массив массивов”, или “неровный массив”. 
Источник: https://javarush.ru/groups/posts/mnogomernye-massivy
 
**Перечислите ссылочные типы.**

Любой класс в Java — это ссылочный тип. String - стандартный пример ссылочного типа + Интерфейсы + Перечисления. Источник: https://javarush.ru/groups/posts/2642-ssihlochnihe-tipih-dannihkh-v-java 
 
**Какая структура у java-файла (внутренности класса не указывать)?**

Общая форма файла, содержащего исходный код Java, может быть следующая:

- одиночный оператор package (необязателен);

- любое количество операторов import (необязательны);

- одиночный открытый (public) класс (необязателен);

- любое количество классов пакетного уровня доступа (необязательны);

- описания интерфейсов (необязательны);

- комментарии (необязательны).

Классы в файле могут отсутствовать. При этом в результате компиляции не будет создан ни один файл с расширением .class.
Источник: И.Н. Блинов,Java. Методы программирования(c.20)

**Какие из элементов структуры являются обязательными?**
 
 Не считая импортов и указания имен пакетов, весь рабочий код находится внутри классов. При этом, за редким исключением, каждый класс должен описываться в отдельном файле, имя файла должно совпадать с именем класса. Например, если создается класс HelloWorldApp, то он сохраняется в файле HelloWorldApp.java.

Один из классов обязательно должен содержать метод-функцию main(), которая является точкой входа в java-программу. В случае однофайловой программы, метод main() должен быть в этом единственном файле. Как называется класс, содержащий main(), не важно. Источник: https://younglinux.info/java/structure
 
**Для чего предназначены пакеты?**
 
 Пакеты позволяют организовать классы логически в наборы. По умолчанию java уже имеет ряд встроенных
пакетов, например, java.lang, java.util, java.io и т.д. Кроме того, пакеты могут иметь вложенные пакеты. 
Организация классов в виде пакетов позволяет избежать конфликта имен между классами. Ведь нередки ситуации, 
когда разработчики называют свои классы одинаковыми именами. Принадлежность к пакету позволяет гарантировать
однозначность имен.
Источник: Https://docs.oracle.com/javase/specs/jls/se17/jls17.pdf
 
**Как выглядит полное имя класса?**
 
 Полным именем класса считается имя, состоящее из всех пакетов, перечисленных через точку и имени класса. Источник: https://javarush.ru/quests/lectures/questsyntax.level02.lecture09
 
**Для чего предназначен оператор import?**

Оператор import служит только для удобства программирования и не является обязательным с формальной точки зрения для создания завершенной программы нa java.Но если в прикладном коде приходится ссылаться на несколько десятков классов, то оператор import значительно сокращает объем вводимого исходного кода. Источник: https://pro-java.ru/java-dlya-nachinayushhix/import-paketov-v-java
 
**Для чего предназначен статический импорт?**

Благодаря статическому импорту появляется возможность ссылаться на статические члены непосредственно по именам, не уточняя их именем класса. Источник: https://pro-java.ru/java-dlya-nachinayushhix/import-paketov-v-java

**Сколько внешних публичных классов можно объявить в одном java-файле?**

В исходном файле может быть только один публичный класс. Источник: http://proglang.su/java/classes-and-objects

**Может ли синтаксически правильный java-файл иметь имя 1.java? Если да, то какие ограничения?**

Нет.
Источник: https://javarush.ru/groups/posts/1392-oshibki-nachinajujshikh-java-programmistov-chastjh-1

**Допустим, в одном java-файле объявлены два синтаксически правильных внешних класса. Какие могут быть результаты компиляции данного файла?**
 
 Будет ошибка компиляции. Источник: https://coderoad.ru/2336692/
 
**Как записывается заголовок метода main() раннер-класса (т.е. класса, который может стартовать из-под JVM)?
Это единственный способ?**
 
 Единственный способ записи: public static void main(String[] args)
 
 Источник: http://grep.cs.msu.ru/kufas.ru/programming_java128.htm
 
**Может ли один java-файл содержать два и более раннер-класса?**
 
 Может. Нужно будет указать какой из этих методов вы хотите запустить. Один из классов, содержащий main(), должен быть общедоступным. Источник: https://qastack.ru/programming/968347
 
**Можно ли определить метод main() с другими модификаторами?**
 Можем написать основной метод со всеми вышеперечисленными ключевыми словами (которые на практике практически не применяются): final static synchronized strictfp void main(final String[] args) { }
 Источник: https://www.baeldung.com/java-main-method
 
**Может ли в классе быть два и более метода main()?**
**Если да, то приведите пример.** 

Да. Пример:

public class MultipleMain{

  public static void main(String args[])
  
  {
  
      main(1);     
      
      main('c');      
      
      main("MyString");
      
  }

  public static void main(int i)
  
  {
     
     System.out.println("Inside Overloaded main()");
     
  }

  public static void main(char i)
  
  {
     
     System.out.println("Inside Overloaded main()");
     
     
  }
  
  
  public static void main(String str)
  
  {
     
     
     System.out.println("Inside Overloaded main()");
  
  
  }


**Может ли в классе быть два метода main(), один из которых раннер, а второй метод main() отличается от первого только отсутствием модификатора static?
Если да, то приведите пример вызова второго метода. **

Нет, так как программа не скомпилируется,ибо main() - статический метод. Источник: http://zonakoda.ru/vsyo-o-metode-main.html

**В корне проекта имеется файл HelloWorld.java, пути к необходимым ресурсам открыты.
Создайте bat-файл для запуска приложения на выполнение.**
 
 @echo off
 
 javac HelloWorld.java
 
 java Main
 
 pause
 
 
**В корне проекта имеется**
**1. папка src для исходных java-файлов, а в ней – файл HelloArgs.java, который выводит приветствие для каждого аргумента командной строки;**
**2. папка bin для class-файлов.**
**Пути к компилятору и JVM открыты, переменная CLASSPATH не установлена.**
**Создайте bat-файл для запуска приложения с двумя аргументами командной строки clever и 25007 на выполнение.**
 
 @echo off
 
javac -sourcepath src -d bin src/HelloArgs.java

java -classpath bin HelloArgs clever 25007
 
**Имеется корректный файл helloWorld.jar.
Создайте bat-файл для запуска приложения на выполнение.**
 
 java -jar HelloWorld.jar
 
**Какие есть виды комментариев?**

//Строчный комментарий

/*

*Блочный комментарий

*/
Источник: https://javarush.ru/groups/posts/607-kommentarii-v-java--ne-vsje-tak-prosto
